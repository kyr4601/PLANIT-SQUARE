# PLANIT SQUARE - TodoList

### Frontend 채용과제 (지원자: 김예린)

## 1. 폴더 구조

planitsquare/</br>
├── index.html</br>
├── src/</br>
│ ├── App.js (전체 상태 관리 / 각 컴포넌트 조립)</br>
│ ├── index.js</br>
│ ├── components/</br>
│ │ ├── TodoInput.js (입력창 컴포넌트)</br>
│ │ ├── TodoList.js (할 일 목록 컴포넌트)</br>
│ │ ├── TodoSummary.js (완료된 할 일 갯수 표시 컴포넌트)</br>
│ │ └── TodoManage.js (목록 전체 완료/삭제 컴포넌트)</br>
│ ├── styles/</br>
│ │ └── index.css</br>
│ ├── utils/</br>
│ │ ├── loadStorage.js (로컬스토리지에서 데이터 불러오는 함수)</br>
│ │ └── saveStorage.js (로컬스토리지에 데이터 저장하는 함수)</br>
│ └── images/</br>
│ ├── check.svg</br>
│ └── delete.svg</br>
└── README.md
</br>
</br>

## 2. 구현 기능

- 할 일 추가 및 로컬 스토리지 저장
- 할 일 완료/완료 취소 (완료된 항목은 체크 아이콘 & 줄긋기)
- 할 일 삭제 (x 버튼 클릭 시 삭제)
- 할 일 선택 후 수정 (완료된 항목은 수정 불가)
- 목록 전체 완료/삭제
- 완료된 할 일 갯수 & 전체 갯수 표시
  </br>
  </br>

## 3. 설계 및 구조

- 컴포넌트 분리 : 입력, 목록, 달성 갯수, 일괄 처리 등 역할에 따라 JS 파일 분리
- 상태 관리 : App.js에서 전체 상태를 state 객체로 관리하며, 하위 컴포넌트에 파라미터로 state 전달
- 스타일링 : index.css에서 관리하며, 반응형 고려
  </br>
  </br>

## 4. 고민한 점

### ✔️ 보일러플레이트에 대한 이해

이번 과제에서 제공된 보일러플레이트 코드를 처음 접했을 때,
App.js에서 전체 상태(state)를 관리하고,
각 기능별 컴포넌트 함수(TodoInput, TodoList 등)에 파라미터로 상태와 콜백 함수를 넘겨주는 구조가
마치 React의 state, props, 컴포넌트 구조를 Vanilla JS로 흉내낸 것처럼 느껴졌습니다.

그래서 다음과 같은 구조로 구현해야함을 이해했습니다.

- App.js가 전체 애플리케이션의 상태를 단일 객체로 관리
- 각 컴포넌트 함수에 필요한 데이터(state)와 동작(콜백 함수)을 props처럼 전달
- 상태가 변경될 때마다 UI를 다시 렌더링

따라서 다음과 같이 구현했습니다.

- 할 일 추가/수정/삭제/선택 등 모든 상태 변화는
  App.js의 setState를 통해 관리
- 각 컴포넌트에서는 전달받은 콜백 함수를 통해
  상태를 직접 변경하지 않고,
  App.js에 요청하는 방식 사용

### ✔️ UX 관점의 선택 체크박스와 완료처리 구분

과제 요구사항에서는 **"목록 완료처리 기능"** 과 **"수정을 위한 선택 체크박스"** 를 구현해야 했습니다.

하지만 일반적인 투두리스트에서는 체크박스가 주로 "할 일 완료" 용도로 사용되기 때문에, 두 기능이 혼동되지 않도록 UX 관점에서 어떻게 분리해 보여줄지 고민이 되었습니다.

**저는 할 일의 제목(텍스트)을 클릭하면 완료 처리가 된다는 점을 사용자에게 자연스럽게 인지시키는 것이 핵심이라고 생각했습니다.**

이를 위해 제목에 마우스를 올렸을 때(hover) 글씨 색이 진해지고, 줄긋기(line-through)가 적용되도록 시각적 피드백을 주어 "여기를 클릭하면 완료 처리된다"는 점을 명확히 드러냈습니다.

또한 입력창 옆의 버튼은 기본적으로 '추가'로 표시되지만, 체크박스를 클릭해 할 일을 선택하면 버튼이 '수정'으로 바뀌도록 하여 각 버튼의 역할을 명확하게 구분했습니다.

이렇게 완료 처리(텍스트 클릭)와 수정(체크박스 선택)의 동작을 시각적으로 분리함으로써 사용자 입장에서 혼동 없이 자연스럽게 기능을 사용할 수 있도록 UX를 설계했습니다.

</br>
</br>

## 5. 트러블슈팅

### editingIndex를 editingId로 바꾸게 된 과정

### 📌문제 상황

처음에는 할 일 목록에서 특정 항목을 선택하거나 수정할 때,
해당 항목의 배열 인덱스(index)를 기준으로 상태를 관리했습니다. </br>
editingIndex라는 변수를 두고,
선택된 할 일의 배열 내 위치(index)를 저장하여
수정/선택/완료 등의 기능을 구현했습니다. </br>
하지만 할 일을 삭제하거나, 목록이 변경될 때
배열의 인덱스가 바뀌면서
원하지 않는 항목이 선택되거나, 잘못된 항목이 수정되는 문제가 발생했습니다.

### 📌원인 분석

1,2,3.. 이런 식의 인덱스(index)는 각 목록의 고유성을 보장하지 못하기 떄문에, 목록 중간에 있는 할 일을 삭제하면 인덱스가 바뀌어 기존에 선택했던 항목이 다른 항목으로 바뀌는 것이었습니다.

ex) 3개의 할 일 목록이 있을 때,

0번째 index -> 장보기</br>
1번째 index -> 공부하기</br>
2번째 index -> 운동하기 </br>

공부하기를 선택한 상태에서 장보기 목록을 삭제하면, 인덱스가 다음과 같은 상태가 되면서, 운동하기가 선택이 됨.

0번째 index -> 공부하기</br>
1번째 index -> 운동하기</br>

이처럼 각 목록의 고유성을 보장해주지 못하기 때문에 배열 인덱스가 아닌 고유한 id를 부여해 관리하도록 변경했습니다.

### 📌해결 과정

각 할 일(todo)에 고유한 id(Date.now() + Math.random())를 부여했습니다.

그리고 상태(state)를 관리할 때
인덱스 대신 해당 id를 기준으로 관리하도록
editingIndex를 editingId로 변경했습니다.

- editingIndex → editingId로 변수명 변경
- 배열 인덱스 비교 → id 비교로 로직 수정
- 할 일 추가 시 고유 id 생성 및 할 일 객체에 포함
  </br>
  </br>

### 📌결과

할 일의 추가/삭제/수정 등 목록이 변경되어도
선택/수정 상태가 올바르게 유지될 수 있었습니다.
